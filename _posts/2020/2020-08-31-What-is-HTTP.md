---
layout: post
title: "HTTP 是什么"
date: "2020-08-31 12:00:00"
category: http
tags: http
author: Archer
---
* content
{:toc}

## 介绍

HTTP 就是超文本传输协议，也就是HyperText Transfer Protocol。




## HTTP 是什么

超文本传输协议

**协议** ：计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。

**传输** ： 计算机世界里专门用来在两点之间传输数据的约定和规范。

**超文本** ： 计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范

HTTP 通常跑在 TCP/IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。此外，还有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。这些协议相互交织，构成了一个协议网，而 HTTP 则处于中心地位。

## 常见网络名词

IP 协议是“Internet Protocol”的缩写，主要目的是解决寻址和路由问题，以及如何在两点间传送数据包。

TCP 协议是“Transmission Control Protocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础。

CDN，全称是“Content Delivery Network”，翻译过来就是“内容分发网络”。它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。

DNS 域名系统（Domain Name System）把域名做一个转换，“映射”到它的真实 IP，这就是所谓的“域名解析”。

URI/URL URI（Uniform Resource Identifier），中文名称是 统一资源标识符，使用它就能够唯一地标记互联网上资源。URI 另一个更常用的表现形式是 URL（Uniform Resource Locator）， 统一资源定位符，也就是我们俗称的“网址”，它实际上是 URI 的一个子集，不过因为这两者几乎是相同的，差异不大，所以通常不会做严格的区分。

URI 主要有三个基本的部分构成：

* 协议名：即访问该资源应当使用的协议，在这里是“http”；
* 主机名：即互联网上主机的标记，可以是域名或 IP 地址，在这里是“nginx.org”；
* 路径：即资源在主机上的位置，使用“/”分隔多级目录，在这里是“/en/download.html”。

SSL/TLS 负责加密通信的安全协议，建立在 TCP/IP 之上，所以也是个可靠的传输协议，可以被用作 HTTP 的下层。SSL 的全称是“Secure Socket Layer”，后改名为 TLS，即“Transport Layer Security”，SSL 使用了许多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套了一个安全的外壳。

代理

* 匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器；
* 透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端；
* 正向代理：靠近客户端，代表客户端向服务器发送请求；
* 反向代理：靠近服务器端，代表服务器响应客户端的请求；

CDN，实际上就是一种代理，它代替源站服务器响应客户端的请求，通常扮演着透明代理和反向代理的角色。

由于代理在传输过程中插入了一个“中间层”，所以可以在这个环节做很多有意思的事情，比如：

* 负载均衡：把访问请求均匀分散到多台机器，实现访问集群化；
* 内容缓存：暂存上下行的数据，减轻后端的压力；
* 安全防护：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器；
* 数据处理：提供压缩、加密等额外的功能。

## 网络分层

### TCP/IP 网络分层模型

TCP/IP 协议总共有四层

第一层叫“链接层”（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。

第二层叫“网际层”或者“网络互连层”（internet layer），IP 协议就处在这一层。因为 IP 协议定义了“IP 地址”的概念，所以就可以在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。

第三层叫“传输层”（transport layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP 协议工作的层次，另外还有它的一个“小伙伴”UDP。

第四层叫“应用层”（application layer），由于下面的三层把基础打得非常好，所以在这一层就“百花齐放”了，有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP 等等，当然还有我们的 HTTP。

> TCP 有状态的协议，需建立连接然后才能发送数据，而且保证数据不丢失不重复。UDP 无状态，不用事先建立连接就可以任意发送数据，但不保证数据一定会发到对方。两个协议的另一个重要区别在于数据的形式。TCP 的数据是连续的“字节流”，有先后顺序，而 UDP 则是分散的小数据包，是顺序发，乱序收。

MAC 层的传输单位是帧（frame）

IP 层的传输单位是包（packet）

TCP 层的传输单位是段（segment）

HTTP 的传输单位则是消息或报文（message）

但这些名词并没有什么本质的区分，可以统称为数据包。

### OSI 网络分层模型

全称是“开放式系统互联通信参考模型”（Open System Interconnection Reference Model）

第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；

第二层：数据链路层，它基本相当于 TCP/IP 的链接层；

第三层：网络层，相当于 TCP/IP 里的网际层；

第四层：传输层，相当于 TCP/IP 里的传输层；

第五层：会话层，维护网络中的连接状态，即保持会话和同步；

第六层：表示层，把数据转换为合适、可理解的语法和语义；

第七层：应用层，面向具体的应用传输数据。

二层转发：设备工作在链接层，获取了数据报的头部信息之后，根据目标的MAC地址，进行本地转发和广播

三层路由：设备工作在IP层，通过分析数据报的头部信息，得到IP地址，根据网段范围，进行本地转发或选择下一个网关。

## 安全与幂等

“安全”是指请求方法不会“破坏”服务器上的资源，即不会对服务器上的资源造成实质的修改。

“幂等”实际上是一个数学用语，被借用到了 HTTP 协议里，意思是多次执行相同的操作，结果也都是相同的，即多次“幂”后结果“相等”。

安全： GET、HEAD
不安全： POST、PUT、DELETE

幂等： GET、HEAD、PUT
非幂等： POST

把 POST 理解成 INSERT，把 PUT 理解成 UPDATE，这样就很清楚了。多次 INSERT 会添加多条记录，而多次 UPDATE 只操作一条记录，而且效果相同。

## HTTP的特点

### 灵活可扩展

“header+body”等，报文里的各个组成部分都没有做严格的语法语义限制

HTTP 协议逐渐增加了请求方法、版本号、状态码、头字段等特性。而 body 也不再限于文本形式的 TXT 或 HTML，而是能够传输图片、音频视频等任意数据

### 可靠传输

HTTP 协议是基于 TCP/IP 的，而 TCP 本身是一个“可靠”的传输协议，所以 HTTP 自然也就继承了这个特性，能够在请求方和应答方之间“可靠”地传输数据。

具体做法与 TCP/UDP 差不多，都是对实际传输的数据（entity）做了一层包装，加上一个头，然后调用 Socket API，通过 TCP/IP 协议栈发送或者接收。

### 应用层协议

HTTP 凭借着可携带任意头字段和实体数据的报文结构，以及连接控制、缓存代理等方便易用的特性，几乎可以传递一切东西，满足各种需求，称得上是一个“万能”的协议。

### 请求 - 应答

请求 - 应答模式也明确了 HTTP 协议里通信双方的定位，永远是请求方先发起连接和请求，是主动的，而应答方只有在收到请求后才能答复，是被动的，如果没有请求时不会有任何动作。

请求 - 应答模式也完全符合 RPC（Remote Procedure Call）的工作模式，可以把 HTTP 请求处理封装成远程函数调用，导致了 WebService、RESTful 和 gPRC 等的出现。

### 无状态

“状态”其实就是客户端或者服务器里保存的一些数据或者标志，记录了通信过程中的一些变化信息。

TCP 协议是有状态的，一开始处于 CLOSED 状态，连接成功后是 ESTABLISHED 状态，断开连接后是 FIN-WAIT 状态，最后又是 CLOSED 状态。

这些“状态”就需要 TCP 在内部用一些数据结构去维护，可以简单地想象成是个标志量，标记当前所处的状态，例如 0 是 CLOSED，2 是 ESTABLISHED 等等。

HTTP，在整个协议里没有规定任何的“状态”，客户端和服务器永远是处在一种“无知”的状态。建立连接前两者互不知情，每次收发的报文也都是互相独立的，没有任何的联系。收发报文也不会对客户端或服务器产生任何影响，连接后也不会要求保存任何信息。

UDP 协议，不过它是无连接也无状态的，顺序发包乱序收包，数据包发出去后就不管了，收到后也不会顺序整理。而 HTTP 是有连接无状态，顺序发包顺序收包，按照收发的顺序管理报文。

> Cookie实现HTTP的"有状态"。

### PATCH 与 PUT 区别

PUT比較正确的定义是 Replace (Create or Update)，
例如 PUT /items/1 的意思是替换 /items/1 ，如果已经存在就替换，沒有就新增；
因此，PUT方法一般会用来更新一个已知资源，除非在创建前，你完全知道自己要创建的对象的URI

PATCH方法是新引入的，是对PUT方法的补充，用来对已知资源进行**局部更新**
HTTP PATCH method require a feature to do partial resource modification.
The existing HTTP PUT method only allows a complete replacement of a document.

假设我们有一个UserInfo，里面有userId， userName， userGender等10个字段。可你的编辑功能因为需求，在某个特别的页面里只能修改userName，这时候的更新怎么做？

人们通常(为徒省事)把一个包含了修改后userName的完整userInfo对象传给后端，做完整更新。但仔细想想，这种做法感觉有点二，而且真心浪费带宽(纯技术上讲，你不关心带宽那是你土豪)。

于是patch诞生，只传一个userName到指定资源去，表示该请求是一个局部更新，后端仅更新接收到的字段。

而put虽然也是更新资源，但要求前端提供的一定是一个完整的资源对象，理论上说，如果你用了put，但却没有提供完整的UserInfo，那么缺了的那些字段应该被清空
